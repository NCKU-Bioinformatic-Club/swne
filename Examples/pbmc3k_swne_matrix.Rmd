---
title: "SWNE Walkthrough starting from a counts matrix"
author: "Yan Wu"
output: html_document
date: 11/12/2018
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(bitmapType="cairo")
```

This is a quick walkthrough demonstrating how to generate SWNE plots starting from a counts matrix using a [3k PBMC](https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k) dataset as an example. You can download the matrix [here](ftp://genome-miner.ucsd.edu/swne_files/pbmc3k_matrix.tsv.gz)


First let's load the required libraries
```{r message=FALSE,warning=FALSE}
library(irlba)
library(Matrix)
library(swne)
```


Next let's load the matrix, convert it to a sparse matrix to save memory, and filter and trim the genes
```{r}
counts <- read.table("~/swne/Data/pbmc3k_matrix.tsv.gz", header = T, sep = "\t")
counts <- as(as.matrix(counts), "dgCMatrix")
counts <- FilterData(counts, min.samples.frac = 0.001, trim = 3, min.nonzero.features = 0,
                     max.sample.sum = Inf)
```

Most scRNA-seq pipelines only use a subset of highly overdispersed genes for analysis. We'll pull out those variable genes here, as well as the cluster labels
```{r}
## Pull out overdispersed genes as defined by Seurat
var.genes <- SelectFeatures(counts, n.features = 2000)
length(var.genes)

## Pull out cell clusters as defined by Seurat
cell.clusters <- factor(sapply(colnames(counts), ExtractField, field = 2, delim = "_"))
names(cell.clusters) <- colnames(counts)
table(cell.clusters)
```

Next we will normalize and run variance stabilization on the counts matrix
```{r}
norm.counts <- ScaleCounts(counts)
```


The easiest way to generate an SWNE embedding is to use the wrapper function `RunSWNE`
```{r}
## Run SWNE
genes.embed <- c("MS4A1", "GNLY", "CD3E", "CD14",
                 "FCER1A", "FCGR3A", "LYZ", "PPBP", "CD8A")
swne.embedding <- RunSWNE(norm.counts, k = 16, var.genes = var.genes, genes.embed = genes.embed)

## Plot SWNE
PlotSWNE(swne.embedding, alpha.plot = 0.4, sample.groups = cell.clusters,
         do.label = T, label.size = 3.5, pt.size = 1, show.legend = F,
         seed = 42)
```


Now we'll go through the SWNE embedding process step by step


We use the `FindNumFactors` function to identify the optimal number of factors to use. This function can be slow for large datasets, since it iterates over different values of `k`, so a simple "hack" is to just set `k` equal to the number of significant principal components.
```{r}
k.range <- seq(2,16,2) ## Range of factors to iterate over
k.err <- FindNumFactors(norm.counts[var.genes,], k.range = k.range, n.cores = 8, do.plot = T)
```


We then run the NMF decomposition. We can initialize the NMF using either Independent Component Analysis (ica), Nonnegative SVD (nnsvd), or a completely random initialization. ICA is recommended for most datasets. The output of `RunNMF` is a list of the gene loadings (W) and NMF embedding (H).
```{r}
k <- 16
nmf.res <- RunNMF(norm.counts[var.genes,], k = k)
```


Next we'll compute the Shared Nearest Neigbhors (SNN) graph. We've noticed PCA tends to be a better reduction
to use for computing the SNN
```{r}
## Run PCA
pca.res <- irlba::irlba(t(norm.counts[var.genes,]), nv = max(k,20), center = Matrix::rowMeans(norm.counts[var.genes,]))
pc.scores <- t(pca.res$u); colnames(pc.scores) <- colnames(norm.counts);

## Compute SNN
snn <- CalcSNN(pc.scores)
```


Run the SWNE embedding. The three key parameters are `alpha.exp`, `snn.exp`, and `n_pull`, which control how the factors and neighboring cells affect the cell coordinates.
```{r message=FALSE,warning=FALSE}
alpha.exp <- 1.25 # Increase this > 1.0 to move the cells closer to the factors. Values > 2 start to distort the data.
snn.exp <- 1 # Lower this < 1.0 to move similar cells closer to each other
n_pull <- 3 # The number of factors pulling on each cell. Must be at least 3.
swne.embedding <- EmbedSWNE(nmf.res$H, SNN = snn, alpha.exp = alpha.exp, snn.exp = snn.exp,
                            n_pull = n_pull)
```


For now, let's hide the factors by setting their names to the empty string `""`. We'll interpret them later
```{r}
swne.embedding$H.coords$name <- ""
```


To help with interpreting these cell clusters, let's pick some key PBMC genes to embed.
```{r}
genes.embed <- c("MS4A1", "GNLY", "CD3E", "CD14",
                 "FCER1A", "FCGR3A", "LYZ", "PPBP", "CD8A")
```


Since we only ran NMF on the overdispersed genes, we need to project the rest of the genes onto the NMF projection to get gene loadings for all genes.
```{r}
nmf.res$W <- ProjectFeatures(norm.counts, nmf.res$H, n.cores = 8)
```


Now we can embed the key PBMC genes onto the visualization and remake the plot
```{r}
swne.embedding <- EmbedFeatures(swne.embedding, nmf.res$W, genes.embed, n_pull = n_pull)
```


Let's make the SWNE plot with the key genes embedded. The closer a cell or a cluster is to a gene, the higher the expression level. We set a seed for reproducible cluster colors, so that every plot will use the same colors to label the clusters.
```{r fig.width=5,fig.height=5}
color.seed <- 42
PlotSWNE(swne.embedding, alpha.plot = 0.4, sample.groups = cell.clusters, do.label = T,
         label.size = 3.5, pt.size = 1, show.legend = F, seed = color.seed)
```


We can validate the embedded genes by overlaying the expression of one of these key genes onto the plot.
```{r fig.width=5,fig.height=5}
gene.use <- "CD8A"
gene.expr <- norm.counts[gene.use,]
FeaturePlotSWNE(swne.embedding, gene.expr, gene.use, alpha.plot = 0.4, label.size = 3.5, pt.size = 1.25)
```



We can also interpret the factors by using the gene loadings matrix. Here, we extract the top 3 genes for each factor by gene loading. Since NMF tends to create a parts-based representation of the data, the factors often correspond to key biological processes or gene modules that explain the data.
```{r}
gene.loadings <- nmf.res$W
top.factor.genes.df <- SummarizeAssocFeatures(gene.loadings, features.return = 3)
head(top.factor.genes.df)
```


And finally, we can make a heatmap to visualize the top factors for each gene
```{r fig.width=3.75,fig.height=5.5}
gene.loadings.heat <- gene.loadings[unique(top.factor.genes.df$feature),]
ggHeat(gene.loadings.heat, clustering = "col")
```


Finally, we can extract cluster colors for compatibility with other plotting methods (i.e. Monocle)
```{r}
color.mapping <- ExtractSWNEColors(swne.embedding, sample.groups = cell.clusters, seed = color.seed)
color.mapping
```
